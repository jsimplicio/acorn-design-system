/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

/* eslint-env node */

const StyleDictionary = require("style-dictionary");
const { createPropertyFormatter } = StyleDictionary.formatHelpers;
const figmaConfig = require("./figma-tokens-config");

const TOKEN_SECTIONS = {
  "Attention Dot": "attention-dot",
  "Background Color": "background-color",
  Border: "border",
  "Box Shadow": "box-shadow",
  Button: "button",
  Checkbox: "checkbox",
  Color: ["brand-color", "color", "platform-color"],
  "Focus Outline": "focus-outline",
  "Font Size": "font-size",
  "Font Weight": "font-weight",
  Heading: "heading",
  Icon: "icon",
  "Input - Text": "input-text",
  "Input - Space": "input-space",
  Link: "link",
  "Outline Color": "outline-color",
  Page: "page",
  Size: "size",
  Space: "space",
  "Table Row": "table-row",
  Text: "text",
  Unspecified: "",
};
const TSHIRT_ORDER = [
  "circle",
  "xxxsmall",
  "xxsmall",
  "xsmall",
  "small",
  "medium",
  "large",
  "xlarge",
  "xxlarge",
  "xxxlarge",
];
const STATE_ORDER = [
  "base",
  "default",
  "root",
  "hover",
  "active",
  "focus",
  "disabled",
];

/**
 * Adds the Mozilla Public License header in one comment and
 * how to make changes in the generated output files via the
 * design-tokens.json file in another comment. Also imports
 * tokens-shared.css when applicable.
 *
 * @param {string} surface
 *  Desktop surface, either "brand" or "platform". Determines
 *  whether or not we need to import tokens-shared.css.
 * @returns {string} Formatted comment header string
 */
let customFileHeader = ({ surface, platform }) => {
  let licenseString = [
    "/* This Source Code Form is subject to the terms of the Mozilla Public",
    " * License, v. 2.0. If a copy of the MPL was not distributed with this",
    " * file, You can obtain one at http://mozilla.org/MPL/2.0/. */",
  ].join("\n");


  let commentString = [
    "/* DO NOT EDIT this file directly, instead modify design-tokens.json",
    " * and run `npm run build` to see your changes. */",
  ].join("\n");

  let cssImport = surface
    ? `@import url("chrome://global/skin/design-system/tokens-shared.css");\n\n`
    : "";
  let layerString =
    !surface && !platform
      ? `@layer tokens-foundation, tokens-prefers-contrast, tokens-forced-colors;\n\n`
      : "";

  return [
    licenseString + "\n\n" + commentString + "\n\n" + cssImport + layerString,
  ];
};

const NEST_MEDIA_QUERIES_COMMENT = `/* Bug 1879900: Can't nest media queries inside of :host, :root selector
   until Bug 1879349 lands */`;

const MEDIA_QUERY_PROPERTY_MAP = {
  "forced-colors": "forcedColors",
  "prefers-contrast": "prefersContrast",
};

function formatBaseTokenNames(str) {
  return str.replaceAll(/(?<tokenName>\w+)-base(?=\b)/g, "$<tokenName>");
}

/**
 * Creates a surface-specific formatter. The formatter is used to build
 * our different CSS files, including "prefers-contrast" and "forced-colors"
 * media queries. See more at
 * https://amzn.github.io/style-dictionary/#/formats?id=formatter
 *
 * @param {string} surface
 *  Which desktop area we are generating CSS for.
 *  Either "brand" (i.e. in-content) or "platform" (i.e. chrome).
 * @returns {Function} - Formatter function that returns a CSS string.
 */
const createDesktopFormat = surface => args => {
  return formatBaseTokenNames(
    customFileHeader({ surface }) +
      formatTokens({
        surface,
        args,
      }) +
      formatTokens({
        mediaQuery: "prefers-contrast",
        surface,
        args,
      }) +
      formatTokens({
        mediaQuery: "forced-colors",
        surface,
        args,
      })
  );
};

/**
 * Creates a simple formatter for acorn-colors.css without layers or anonymous-content-host
 * @returns {Function} - Formatter function that returns a simple CSS string.
 */
const createSimpleColorsFormat = () => args => {
  // Custom header without layers - only license, no DO NOT EDIT comment
  let licenseString = [
    "/* This Source Code Form is subject to the terms of the Mozilla Public",
    " * License, v. 2.0. If a copy of the MPL was not distributed with this",
    " * file, You can obtain one at http://mozilla.org/MPL/2.0/. */",
  ].join("\n");
  
  let simpleHeader = licenseString + "\n\n";
  
  return formatBaseTokenNames(
    simpleHeader +
      formatSimpleTokens({
        args,
      }) +
      formatSimpleTokens({
        mediaQuery: "prefers-contrast",
        args,
      }) +
      formatSimpleTokens({
        mediaQuery: "forced-colors",
        args,
      })
  );
};

/**
 * Formats a subset of tokens into simple CSS without layers. Used for acorn-colors.css.
 *
 * @param {object} tokenArgs
 * @param {string} [tokenArgs.mediaQuery]
 *  Media query formatted CSS should be wrapped in.
 * @param {object} tokenArgs.args
 *  Formatter arguments provided by style-dictionary.
 * @returns {string} Tokens formatted into a simple CSS string.
 */
function formatSimpleTokens({ mediaQuery, args }) {
  let prop = MEDIA_QUERY_PROPERTY_MAP[mediaQuery] ?? "default";
  let dictionary = Object.assign({}, args.dictionary);
  let tokens = [];

  dictionary.allTokens.forEach(token => {
    // Try to get value from multiple sources: shared, brand, or default
    let originalVal = getOriginalTokenValue(token, prop, "");
    
    // If no shared value, try brand context for brand-specific tokens
    if (originalVal === undefined && typeof token.original.value === 'object') {
      originalVal = getOriginalTokenValue(token, prop, "brand");
    }
    
    if (originalVal != undefined) {
      let formattedToken = transformToken(
        token,
        originalVal,
        dictionary,
        ""
      );
      tokens.push(formattedToken);
    }
  });

  if (!tokens.length) {
    return "";
  }

  dictionary.allTokens = dictionary.allProperties = tokens;

  let formattedVars = formatVariables({
    format: "css",
    dictionary,
    outputReferences: args.options.outputReferences,
    formatting: {
      indentation: "  ",
    },
  });

  if (mediaQuery) {
    return `
@media (${mediaQuery}) {
  :root {
${formattedVars}
  }
}
`;
  }

  return `:root {
${formattedVars}
}
`;
}

/**
 * Formats a subset of tokens into CSS. Wraps token CSS in a media query when
 * applicable.
 *
 * @param {object} tokenArgs
 * @param {string} [tokenArgs.mediaQuery]
 *  Media query formatted CSS should be wrapped in. This is used
 *  to determine what property we are parsing from the token values.
 * @param {string} [tokenArgs.surface]
 *  Specifies a desktop surface, either "brand" or "platform".
 * @param {object} tokenArgs.args
 *  Formatter arguments provided by style-dictionary. See more at
 *  https://amzn.github.io/style-dictionary/#/formats?id=formatter
 * @returns {string} Tokens formatted into a CSS string.
 */
function formatTokens({ mediaQuery, surface, args }) {
  let prop = MEDIA_QUERY_PROPERTY_MAP[mediaQuery] ?? "default";
  let dictionary = Object.assign({}, args.dictionary);
  let tokens = [];

  dictionary.allTokens.forEach(token => {
    let originalVal = getOriginalTokenValue(token, prop, surface);
    if (originalVal != undefined) {
      let formattedToken = transformToken(
        token,
        originalVal,
        dictionary,
        surface
      );
      tokens.push(formattedToken);
    }
  });

  if (!tokens.length) {
    return "";
  }

  dictionary.allTokens = dictionary.allProperties = tokens;

  let formattedVars = formatVariables({
    format: "css",
    dictionary,
    outputReferences: args.options.outputReferences,
    formatting: {
      indentation: mediaQuery ? "      " : "    ",
    },
  });

  let layer = `tokens-${mediaQuery ?? "foundation"}`;
  // Weird spacing below is unfortunately necessary for formatting the built CSS.
  if (mediaQuery) {
    return `
${NEST_MEDIA_QUERIES_COMMENT}
@layer ${layer} {
  @media (${mediaQuery}) {
    :root,
    :host(.anonymous-content-host) {
${formattedVars}
    }
  }
}
`;
  }

  return `@layer ${layer} {
  :root,
  :host(.anonymous-content-host) {
${formattedVars}
  }
}
`;
}

/**
 * Finds the original value of a token for a given media query and surface.
 *
 * @param {object} token - Token object parsed by style-dictionary.
 * @param {string} prop - Name of the property we're querying for.
 * @param {string} surface
 *  The desktop surface we're generating CSS for, either "brand" or "platform".
 * @returns {string} The original token value based on our parameters.
 */
function getOriginalTokenValue(token, prop, surface) {
  if (surface) {
    return token.original.value[surface]?.[prop];
  } else if (prop == "default" && typeof token.original.value != "object") {
    return token.original.value;
  }
  return token.original.value?.[prop];
}

/**
 * Updates a token's value to the relevant original value after resolving
 * variable references. Also checks for surface specific comments.
 *
 * @param {object} token - Token object parsed from JSON by style-dictionary.
 * @param {string} originalVal
 *  Original value of the token for the combination of surface and media query.
 * @param {object} dictionary
 *  Object of transformed tokens and helper fns provided by style-dictionary.
 * @param {string} surface
 *  The desktop surface we're generating CSS for, either "brand", "platform",
 *  or "shared".
 * @returns {object} Token object with an updated value.
 */
function transformToken(token, originalVal, dictionary, surface) {
  let value = originalVal;
  if (dictionary.usesReference(value)) {
    dictionary.getReferences(value).forEach(ref => {
      value = value.replace(`{${ref.path.join(".")}}`, `var(--${ref.name})`);
    });
  }
  let surfaceComment = token.original?.value[surface]?.comment;
  return { ...token, value, comment: surfaceComment ?? token.comment };
}

/**
 * Creates a light-dark transform that works for a given surface. Registers
 * the transform with style-dictionary and returns the transform's name.
 *
 * @param {string} surface
 *  The desktop surface we're generating CSS for, either "brand", "platform",
 *  or "shared".
 * @returns {string} Name of the transform that was registered.
 */
const createLightDarkTransform = surface => {
  let name = `lightDarkTransform/${surface}`;

  // Matcher function for determining if a token's value needs to undergo
  // a light-dark transform.
  let matcher = token => {
    if (surface != "shared") {
      return (
        token.original.value[surface]?.light &&
        token.original.value[surface]?.dark
      );
    }
    return token.original.value.light && token.original.value.dark;
  };

  // Function that uses the token's original value to create a new "default"
  // light-dark value and updates the original value object.
  let transformer = token => {
    if (surface != "shared") {
      let lightDarkVal = `light-dark(${token.original.value[surface].light}, ${token.original.value[surface].dark})`;
      token.original.value[surface].default = lightDarkVal;
      return token.value;
    }
    let value = `light-dark(${token.original.value.light}, ${token.original.value.dark})`;
    token.original.value.default = value;
    return value;
  };

  StyleDictionary.registerTransform({
    type: "value",
    transitive: true,
    name,
    matcher,
    transformer,
  });

  return name;
};

/**
 * Format the tokens dictionary to a string. This mostly defers to
 * StyleDictionary.createPropertyFormatter but first it sorts the tokens based
 * on the groupings in TOKEN_SECTIONS and adds comment headers to CSS output.
 *
 * @param {object} options
 *  Options for tokens to format.
 * @param {string} options.format
 *  The format to output. Supported: "css"
 * @param {object} options.dictionary
 *  The tokens dictionary.
 * @param {string} options.outputReferences
 *  Whether to output variable references.
 * @param {object} options.formatting
 *  The formatting settings to be passed to createPropertyFormatter.
 * @returns {string} The formatted tokens.
 */
function formatVariables({ format, dictionary, outputReferences, formatting }) {
  let lastSection = [];
  let propertyFormatter = createPropertyFormatter({
    outputReferences,
    dictionary,
    format,
    formatting,
  });

  let outputParts = [];
  let remainingTokens = [...dictionary.allTokens];
  let isFirst = true;

  function tokenParts(name) {
    let lastDash = name.lastIndexOf("-");
    let suffix = name.substring(lastDash + 1);
    if (TSHIRT_ORDER.includes(suffix) || STATE_ORDER.includes(suffix)) {
      return [name.substring(0, lastDash), suffix];
    }
    return [name, ""];
  }

  for (let [label, selector] of Object.entries(TOKEN_SECTIONS)) {
    let sectionMatchers = Array.isArray(selector) ? selector : [selector];
    let sectionParts = [];

    remainingTokens = remainingTokens.filter(token => {
      if (
        sectionMatchers.some(m =>
          m.test ? m.test(token.name) : token.name.startsWith(m)
        )
      ) {
        sectionParts.push(token);
        return false;
      }
      return true;
    });

    if (sectionParts.length) {
      sectionParts.sort((a, b) => {
        let aName = formatBaseTokenNames(a.name);
        let bName = formatBaseTokenNames(b.name);
        let [aToken, aSuffix] = tokenParts(aName);
        let [bToken, bSuffix] = tokenParts(bName);
        if (aSuffix || bSuffix) {
          if (aToken == bToken) {
            let aSize = TSHIRT_ORDER.indexOf(aSuffix);
            let bSize = TSHIRT_ORDER.indexOf(bSuffix);
            if (aSize != -1 && bSize != -1) {
              return aSize - bSize;
            }
            let aState = STATE_ORDER.indexOf(aSuffix);
            let bState = STATE_ORDER.indexOf(bSuffix);
            if (aState != -1 && bState != -1) {
              return aState - bState;
            }
          }
        }
        return aToken.localeCompare(bToken, undefined, { numeric: true });
      });

      let headingParts = [];
      if (!isFirst) {
        headingParts.push("");
      }
      isFirst = false;

      let sectionLevel = "**";
      let labelParts = label.split("/");
      for (let i = 0; i < labelParts.length; i++) {
        if (labelParts[i] != lastSection[i]) {
          headingParts.push(
            `${formatting.indentation}/${sectionLevel} ${labelParts[i]} ${sectionLevel}/`
          );
        }
        sectionLevel += "*";
      }
      lastSection = labelParts;

      outputParts = outputParts.concat(
        headingParts.concat(sectionParts.map(propertyFormatter))
      );
    }
  }

  return outputParts.join("\n");
}

// Easy way to grab variable values later for display.
let variableLookupTable = {};

function storybookJSFormat(args) {
  let dictionary = Object.assign({}, args.dictionary);
  let resolvedTokens = dictionary.allTokens.map(token => {
    let tokenVal = resolveReferences(dictionary, token.original);
    return {
      name: token.name,
      ...tokenVal,
    };
  });
  dictionary.allTokens = dictionary.allProperties = resolvedTokens;

  let parsedData = JSON.parse(
    formatBaseTokenNames(
      StyleDictionary.format["javascript/module-flat"]({
        ...args,
        dictionary,
      })
    )
      .trim()
      .replaceAll(/(^module\.exports\s*=\s*|\;$)/g, "")
  );
  let storybookTables = formatTokensTablesData(parsedData);

  return `${customFileHeader({ platform: "storybook" })}
  export const storybookTables = ${JSON.stringify(storybookTables)};

  export const variableLookupTable = ${JSON.stringify(variableLookupTable)};
  `;
}

function resolveReferences(dictionary, originalVal) {
  let resolvedValues = {};
  Object.entries(originalVal).forEach(([key, value]) => {
    if (typeof value === "object" && value != null) {
      resolvedValues[key] = resolveReferences(dictionary, value);
    } else {
      let resolvedVal = getValueWithReferences(dictionary, value);
      resolvedValues[key] = resolvedVal;
    }
  });
  return resolvedValues;
}

function getValueWithReferences(dictionary, value) {
  let valWithRefs = value;
  if (dictionary.usesReference(value)) {
    dictionary.getReferences(value).forEach(ref => {
      valWithRefs = valWithRefs.replace(
        `{${ref.path.join(".")}}`,
        `var(--${ref.name})`
      );
    });
  }
  return valWithRefs;
}

function formatTokensTablesData(tokensData) {
  let tokensTables = {};
  Object.entries(tokensData).forEach(([key, value]) => {
    variableLookupTable[key] = value;
    let formattedToken = {
      value,
      name: `--${key}`,
    };

    let tableName = getTableName(key);
    if (tokensTables[tableName]) {
      tokensTables[tableName].push(formattedToken);
    } else {
      tokensTables[tableName] = [formattedToken];
    }
  });
  return tokensTables;
}

const SINGULAR_TABLE_CATEGORIES = [
  "button",
  "color",
  "link",
  "size",
  "space",
  "opacity",
  "outline",
  "padding",
  "margin",
];

function getTableName(tokenName) {
  if (tokenName.includes("page-main")) {
    return "size";
  }

  let replacePattern =
    /^(button-|input-text-|input-|focus-|checkbox-|table-row-|attention-dot-)/;
  if (tokenName.match(replacePattern)) {
    tokenName = tokenName.replace(replacePattern, "");
  }
  let [category, type] = tokenName.split("-");
  return SINGULAR_TABLE_CATEGORIES.includes(category) || !type
    ? category
    : `${category}-${type}`;
}

module.exports = {
  source: ["design-tokens.json"],
  format: {
    "css/variables/colors": createDesktopFormat(""),
    "css/variables/shared": createDesktopFormat(),
    "css/variables/brand": createDesktopFormat("brand"),
    "css/variables/platform": createDesktopFormat("platform"),
    "css/variables/simple-colors": createSimpleColorsFormat(),
    "javascript/storybook": storybookJSFormat,
    ...figmaConfig.formats,
  },
  platforms: {
    css: {
      options: {
        outputReferences: true,
        showFileHeader: false,
      },
      transforms: [
        ...StyleDictionary.transformGroup.css,
        ...["shared", "platform", "brand"].map(createLightDarkTransform),
      ],
      files: [
        {
          destination: "tokens-shared.css",
          format: "css/variables/shared",
        },
        {
          destination: "tokens-brand.css",
          format: "css/variables/brand",
          filter: token =>
            typeof token.original.value == "object" &&
            token.original.value.brand,
        },
        {
          destination: "tokens-platform.css",
          format: "css/variables/platform",
          filter: token =>
            typeof token.original.value == "object" &&
            token.original.value.platform,
        },
	{
	  destination: "acorn-tokens/acorn-colors.css",
	  format: "css/variables/simple-colors",
	  filter: token => {
	    // Exclude shadow-related color tokens (they go to shadows)
	    if (token.name.includes('shadow') && token.name.includes('color')) return false;
	    
	    // Match ALL color-related tokens including:
	    // - Color palettes (color-red-10, color-blue-50, etc.)
	    // - Background colors (background-color-*)
	    // - Border colors (border-color-*)
	    // - Text colors (text-color-*)
	    // - Icon colors (icon-color-*)
	    // - Link colors (link-color-*)
	    // - Table colors (table-*-color)
	    // - Outline colors (outline-color-*)
	    // - Attention dot color
	    // - Focus outline color
	    const isColorToken = token.name.startsWith('color-') ||
	                        token.name.includes('-color') ||
	                        token.name.startsWith('background-color') ||
	                        token.name.startsWith('border-color') ||
	                        token.name.startsWith('text-color') ||
	                        token.name.startsWith('icon-color') ||
	                        token.name.startsWith('link-color') ||
	                        token.name.startsWith('link-') ||
	                        token.name.startsWith('table-') ||
	                        token.name.startsWith('outline-color') ||
	                        token.name === 'attention-dot-color' ||
	                        token.name === 'focus-outline-color' ||
	                        // Include button color tokens
	                        (token.name.includes('button-') && token.name.includes('color')) ||
	                        // Include checkbox color tokens
	                        (token.name.includes('checkbox-') && token.name.includes('color')) ||
	                        // Include input color tokens
	                        (token.name.includes('input-') && token.name.includes('color')) ||
	                        // Include icon color tokens
	                        (token.name.startsWith('icon-') && token.name.includes('color'));
	    
	    if (!isColorToken) return false;
	    
	    // For simple values (not objects), include them
	    if (typeof token.original.value !== 'object') {
	      return true;
	    }
	    
	    // Include tokens that have brand, shared (light/dark), or non-platform-only definitions
	    const hasSharedOrBrand = token.original.value.brand ||
	                            token.original.value.light ||
	                            token.original.value.dark ||
	                            token.original.value.default;
	    
	    const isPlatformOnly = token.original.value.platform &&
	                          Object.keys(token.original.value).length === 1;
	    
	    return hasSharedOrBrand || !isPlatformOnly;
	  }
	},
	{
	  destination: "acorn-tokens/acorn-typography.css",
	  format: "css/variables/simple-colors",
	  filter: token => {
	    // Exclude input-related tokens (buttons, checkboxes, input-text, etc.)
	    if (token.name.includes('button-') || token.name.startsWith('button-') ||
	        token.name.includes('checkbox-') || token.name.startsWith('checkbox-') ||
	        token.name.includes('input-') || token.name.startsWith('input-')) return false;
	    
	    // Match all typography-related tokens:
	    // - Font tokens (font-size, font-weight, etc.)
	    // - Heading tokens (heading-font-size-*, heading-font-weight)
	    // - Text tokens (text-color is excluded as it goes to colors)
	    const isTypographyToken = token.name.startsWith('font-') ||
	                             token.name.includes('font-') ||
	                             token.name.startsWith('heading-') ||
	                             (token.name.startsWith('text-') && !token.name.includes('color'));
	    
	    if (!isTypographyToken) return false;
	    
	    // For simple values (not objects), include them
	    if (typeof token.original.value !== 'object') {
	      return true;
	    }
	    
	    // Include tokens that have brand, shared, or non-platform-only definitions
	    const hasSharedOrBrand = token.original.value.brand ||
	                            token.original.value.light ||
	                            token.original.value.dark ||
	                            token.original.value.default;
	    
	    const isPlatformOnly = token.original.value.platform &&
	                          Object.keys(token.original.value).length === 1;
	    
	    return hasSharedOrBrand || !isPlatformOnly;
	  }
	},
	{
	  destination: "acorn-tokens/acorn-space.css",
	  format: "css/variables/simple-colors",
	  filter: token => {
	    // Exclude input-related tokens (buttons, checkboxes, input-text, etc.)
	    if (token.name.includes('button-') || token.name.startsWith('button-') ||
	        token.name.includes('checkbox-') || token.name.startsWith('checkbox-') ||
	        token.name.includes('input-') || token.name.startsWith('input-')) return false;
	    
	    // Match all space-related tokens:
	    // - Space tokens (space-*, --space-*)
	    // - Padding tokens (padding-*, --*-padding)
	    // - Margin tokens (margin-*, --*-margin)
	    const isSpaceToken = token.name.startsWith('space-') ||
	                       token.name.includes('-space') ||
	                       token.name.startsWith('padding-') ||
	                       token.name.includes('-padding') ||
	                       token.name.startsWith('margin-') ||
	                       token.name.includes('-margin');
	    
	    if (!isSpaceToken) return false;
	    
	    // For simple values (not objects), include them
	    if (typeof token.original.value !== 'object') {
	      return true;
	    }
	    
	    // Include tokens that have brand, shared, or non-platform-only definitions
	    const hasSharedOrBrand = token.original.value.brand ||
	                            token.original.value.light ||
	                            token.original.value.dark ||
	                            token.original.value.default;
	    
	    const isPlatformOnly = token.original.value.platform &&
	                          Object.keys(token.original.value).length === 1;
	    
	    return hasSharedOrBrand || !isPlatformOnly;
	  }
	},
	{
	  destination: "acorn-tokens/acorn-size.css",
	  format: "css/variables/simple-colors",
	  filter: token => {
	    // Match all size-related tokens:
	    // - Size tokens (size-*, --size-*)
	    // - Width tokens (width-*, --*-width)
	    // - Height tokens (height-*, --*-height)
	    // - Icon size tokens (icon-size-*)
	    // - Page dimensions (page-*-width, page-*-height)
	    // - Button size tokens (button-size-*) but not color or other non-size properties
	    const isSizeToken = token.name.startsWith('size-') ||
	                       token.name.includes('-size') ||
	                       token.name.startsWith('width-') ||
	                       token.name.includes('-width') ||
	                       token.name.startsWith('height-') ||
	                       token.name.includes('-height') ||
	                       token.name.startsWith('icon-size') ||
	                       token.name.startsWith('page-') ||
	                       token.name.includes('page-') ||
	                       // Include button size tokens but exclude other button properties
	                       (token.name.includes('button-size') && !token.name.includes('color'));
	    
	    if (!isSizeToken) return false;

	    // Exclude border-width from the size file (goes to borders)
	    if (token.name.includes('border-width')) return false;
	    
	    // Exclude other input-related non-size tokens
	    if ((token.name.includes('button') || token.name.includes('checkbox') || token.name.includes('input')) && 
	        !token.name.includes('-size') && !token.name.includes('-width') && !token.name.includes('-height')) {
	      return false;
	    }
	    
	    // For simple values (not objects), include them
	    if (typeof token.original.value !== 'object') {
	      return true;
	    }
	    
	    // Include tokens that have brand, shared, or non-platform-only definitions
	    const hasSharedOrBrand = token.original.value.brand ||
	                            token.original.value.light ||
	                            token.original.value.dark ||
	                            token.original.value.default;
	    
	    const isPlatformOnly = token.original.value.platform &&
	                          Object.keys(token.original.value).length === 1;
	    
	    return hasSharedOrBrand || !isPlatformOnly;
	  }
	},
	{
	  destination: "acorn-tokens/acorn-borders.css",
	  format: "css/variables/simple-colors",
	  filter: token => {
	    // Exclude input-related tokens (buttons, checkboxes, input-text, etc.)
	    if (token.name.includes('button') || token.name.includes('checkbox') || token.name.includes('input')) return false;

	    // Match all border-related tokens except colors
	    const isBorderToken = (token.name.startsWith('border-') || token.name.includes('-border')) && !token.name.includes('-color');
	    
	    if (!isBorderToken) return false;
	    
	    // For simple values (not objects), include them
	    if (typeof token.original.value !== 'object') {
	      return true;
	    }
	    
	    // Include tokens that have brand, shared, or non-platform-only definitions
	    const hasSharedOrBrand = token.original.value.brand ||
	                            token.original.value.light ||
	                            token.original.value.dark ||
	                            token.original.value.default;
	    
	    const isPlatformOnly = token.original.value.platform &&
	                          Object.keys(token.original.value).length === 1;
	    
	    return hasSharedOrBrand || !isPlatformOnly;
	  }
	},
	{
	  destination: "acorn-tokens/acorn-shadows.css",
	  format: "css/variables/simple-colors",
	  filter: token => {
	    // Match shadow-related token names (including box-shadow)
	    const isShadowToken = token.name.includes('shadow') ||
	                         token.name.includes('box-shadow') ||
	                         token.name.startsWith('box-shadow-');
	    
	    if (!isShadowToken) return false;
	    
	    // For simple values (not objects), include them
	    if (typeof token.original.value !== 'object') {
	      return true;
	    }
	    
	    // Include tokens that have brand, shared, or non-platform-only definitions
	    const hasSharedOrBrand = token.original.value.brand ||
	                            token.original.value.light ||
	                            token.original.value.dark ||
	                            token.original.value.default;
	    
	    const isPlatformOnly = token.original.value.platform &&
	                          Object.keys(token.original.value).length === 1;
	    
	    return hasSharedOrBrand || !isPlatformOnly;
	  }
	},
	{
	  destination: "acorn-tokens/acorn-inputs.css",
	  format: "css/variables/simple-colors",
	  filter: token => {
	    // Match input-related token names (buttons, checkboxes, input-text, etc.) and focus outline tokens (except color)
	    const isInputToken = token.name.includes('button-') || 
	                        token.name.startsWith('button-') ||
	                        token.name.includes('checkbox-') ||
	                        token.name.startsWith('checkbox-') ||
	                        token.name.includes('input-') ||
	                        token.name.startsWith('input-') ||
	                        (token.name.startsWith('focus-outline') && !token.name.includes('-color'));
	    
	    if (!isInputToken) return false;
	    
	    // Exclude color tokens as they go to colors file
	    if (token.name.includes('-color')) return false;
	    
	    // Exclude size tokens as they go to size file
	    if (token.name.includes('-size')) return false;
	    
	    // For simple values (not objects), include them
	    if (typeof token.original.value !== 'object') {
	      return true;
	    }
	    
	    // Include tokens that have brand, shared, or non-platform-only definitions
	    const hasSharedOrBrand = token.original.value.brand ||
	                            token.original.value.light ||
	                            token.original.value.dark ||
	                            token.original.value.default;
	    
	    const isPlatformOnly = token.original.value.platform &&
	                          Object.keys(token.original.value).length === 1;
	    
	    return hasSharedOrBrand || !isPlatformOnly;
	  }
	}
      ],
    },
    storybook: {
      options: {
        outputReferences: true,
        showFileHeader: false,
      },
      transforms: [
        ...StyleDictionary.transformGroup.css,
        ...["shared", "platform", "brand"].map(createLightDarkTransform),
      ],
      files: [
        {
          destination: "tokens-storybook.mjs",
          format: "javascript/storybook",
        },
      ],
    },
    figma: figmaConfig.platform,
  },
};
